// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE

import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Belt_List from "bs-platform/lib/es6/belt_List.js";
import * as Caml_builtin_exceptions from "bs-platform/lib/es6/caml_builtin_exceptions.js";

var setDomProps = function (node,props){
  Object.keys(props).forEach(key => {
    if (key === 'checked' || key === 'value') {
      node[key] = props[key]
    } else if (typeof props[key] === 'function') {
      node[key] = props[key]
    } else {
      node.setAttribute(key, props[key])
    }
  })
};

function createElement(typ, domProps) {
  var node = document.createElement(typ);
  setDomProps(node, domProps);
  return node;
}

function updateDomProps(node, _, newProps) {
  return setDomProps(node, newProps);
}

function getDomNode(_tree) {
  while(true) {
    var tree = _tree;
    switch (tree.tag | 0) {
      case 0 : 
          return tree[1];
      case 1 : 
          return tree[2];
      case 2 : 
          _tree = tree[0][/* tree */1];
          continue ;
      
    }
  };
}

function createTree(el) {
  switch (el.tag | 0) {
    case 0 : 
        return /* PString */Block.__(0, [el[0]]);
    case 1 : 
        return /* PBuiltin */Block.__(1, [
                  el[0],
                  el[1],
                  Belt_List.map(el[2], createTree)
                ]);
    case 2 : 
        var custom = Curry._1(el[0][/* init */0], /* () */0);
        return /* PCustom */Block.__(2, [
                  custom,
                  createTree(Curry._1(custom[/* render */0], /* () */0))
                ]);
    
  }
}

function inflateTree(el) {
  switch (el.tag | 0) {
    case 0 : 
        var contents = el[0];
        return /* TString */Block.__(0, [
                  contents,
                  document.createTextNode(contents)
                ]);
    case 1 : 
        var domProps = el[1];
        var string = el[0];
        var node = createElement(string, domProps);
        var children = Belt_List.map(el[2], inflateTree);
        Belt_List.forEach(children, (function (child) {
                node.appendChild(getDomNode(child));
                return /* () */0;
              }));
        return /* TBuiltin */Block.__(1, [
                  string,
                  domProps,
                  node,
                  children
                ]);
    case 2 : 
        var custom = el[0];
        var tree = inflateTree(el[1]);
        var container = /* record */[
          /* custom */custom,
          /* tree */tree
        ];
        Curry._1(custom[/* onChange */1], (function (custom) {
                container[/* custom */0] = custom;
                container[/* tree */1] = reconcileTrees(container[/* tree */1], Curry._1(custom[/* render */0], /* () */0));
                return /* () */0;
              }));
        return /* TCustom */Block.__(2, [container]);
    
  }
}

function reconcileTrees(prev, next) {
  var exit = 0;
  switch (prev.tag | 0) {
    case 0 : 
        var node = prev[1];
        switch (next.tag | 0) {
          case 0 : 
              var b = next[0];
              if (prev[0] === b) {
                return prev;
              } else {
                node.textContent = b;
                return /* TString */Block.__(0, [
                          b,
                          node
                        ]);
              }
          case 1 : 
          case 2 : 
              exit = 1;
              break;
          
        }
        break;
    case 1 : 
        var node$1 = prev[2];
        switch (next.tag | 0) {
          case 1 : 
              var b$1 = next[0];
              if (prev[0] === b$1) {
                var bProps = next[1];
                setDomProps(node$1, bProps);
                return /* TBuiltin */Block.__(1, [
                          b$1,
                          bProps,
                          node$1,
                          Curry._1(reconcileChildren(node$1, prev[3]), next[2])
                        ]);
              } else {
                exit = 1;
              }
              break;
          case 0 : 
          case 2 : 
              exit = 1;
              break;
          
        }
        break;
    case 2 : 
        var a = prev[0];
        switch (next.tag | 0) {
          case 0 : 
          case 1 : 
              exit = 1;
              break;
          case 2 : 
              var match = Curry._1(next[0][/* clone */1], a[/* custom */0]);
              if (match !== undefined) {
                var custom = match;
                var tree = reconcileTrees(a[/* tree */1], Curry._1(custom[/* render */0], /* () */0));
                a[/* custom */0] = custom;
                a[/* tree */1] = tree;
                return /* TCustom */Block.__(2, [a]);
              } else {
                var tree$1 = inflateTree(createTree(next));
                getDomNode(prev).replaceWith(getDomNode(tree$1));
                return tree$1;
              }
          
        }
        break;
    
  }
  if (exit === 1) {
    var tree$2 = inflateTree(createTree(next));
    getDomNode(prev).replaceWith(getDomNode(tree$2));
    return tree$2;
  }
  
}

function reconcileChildren(_, _$1) {
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "Basic.re",
          126,
          52
        ]
      ];
}

function mount(el, node) {
  var tree = inflateTree(createTree(el));
  node.appendChild(getDomNode(tree));
  return /* () */0;
}

export {
  setDomProps ,
  createElement ,
  updateDomProps ,
  getDomNode ,
  createTree ,
  inflateTree ,
  reconcileTrees ,
  reconcileChildren ,
  mount ,
  
}
/* No side effect */
