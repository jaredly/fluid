// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE

import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Belt_List from "bs-platform/lib/es6/belt_List.js";

var setDomProps = function (node,props){
  Object.keys(props).forEach(key => {
    if (key === 'checked' || key === 'value') {
      node[key] = props[key]
    } else if (typeof props[key] === 'function') {
      node[key] = props[key]
    } else {
      node.setAttribute(key, props[key])
    }
  })
};

function createElement(typ, domProps) {
  var node = document.createElement(typ);
  setDomProps(node, domProps);
  return node;
}

function updateDomProps(node, _, newProps) {
  return setDomProps(node, newProps);
}

function makeComponent(maker, props) {
  return /* record */[
          /* init */(function () {
              var onChange = /* record */[/* contents */(function () {
                    console.log("SetState before render ignored");
                    return /* () */0;
                  })];
              console.log("Mount!", maker);
              return /* WithState */[/* record */[
                        /* identity */maker,
                        /* props */props,
                        /* state */Curry._1(maker[/* initialState */0], props),
                        /* render */(function (props, state) {
                            return Curry._3(maker[/* render */2], props, state, (function (state) {
                                          return Curry._1(onChange[0], state);
                                        }));
                          }),
                        /* onChange */(function (handler) {
                            onChange[0] = handler;
                            return /* () */0;
                          })
                      ]];
            }),
          /* clone */(function (param) {
              var contents = param[0];
              if (contents[/* identity */0] === maker) {
                return /* WithState */[/* record */[
                          /* identity */contents[/* identity */0],
                          /* props */props,
                          /* state */contents[/* state */2],
                          /* render */contents[/* render */3],
                          /* onChange */contents[/* onChange */4]
                        ]];
              }
              
            })
        ];
}

function component(render) {
  var partial_arg_000 = function () {
    return /* () */0;
  };
  var partial_arg_001 = function (_, state) {
    return state;
  };
  var partial_arg_002 = function (props, _, _$1) {
    return Curry._1(render, props);
  };
  var partial_arg = /* record */[
    partial_arg_000,
    partial_arg_001,
    partial_arg_002
  ];
  return (function (param) {
      return makeComponent(partial_arg, param);
    });
}

function statefulComponent(initialState, newStateForProps, render) {
  var partial_arg_001 = /* newStateForProps */newStateForProps !== undefined ? newStateForProps : (function (_, state) {
        return state;
      });
  var partial_arg = /* record */[
    /* initialState */initialState,
    partial_arg_001,
    /* render */render
  ];
  return (function (param) {
      return makeComponent(partial_arg, param);
    });
}

var Maker = /* module */[
  /* makeComponent */makeComponent,
  /* component */component,
  /* statefulComponent */statefulComponent
];

function render(param) {
  var match = param[0];
  return Curry._2(match[/* render */3], match[/* props */1], match[/* state */2]);
}

function onChange(param, handler) {
  var contents = param[0];
  return Curry._1(contents[/* onChange */4], (function (state) {
                return Curry._1(handler, /* WithState */[/* record */[
                              /* identity */contents[/* identity */0],
                              /* props */contents[/* props */1],
                              /* state */state,
                              /* render */contents[/* render */3],
                              /* onChange */contents[/* onChange */4]
                            ]]);
              }));
}

function getDomNode(_tree) {
  while(true) {
    var tree = _tree;
    switch (tree.tag | 0) {
      case 0 : 
          return tree[1];
      case 1 : 
          return tree[2];
      case 2 : 
          _tree = tree[0][/* mountedTree */1];
          continue ;
      
    }
  };
}

function instantiateTree(el) {
  switch (el.tag | 0) {
    case 0 : 
        return /* IString */Block.__(0, [el[0]]);
    case 1 : 
        return /* IBuiltin */Block.__(1, [
                  el[0],
                  el[1],
                  Belt_List.map(el[2], instantiateTree)
                ]);
    case 2 : 
        var custom = Curry._1(el[0][/* init */0], /* () */0);
        return /* ICustom */Block.__(2, [
                  custom,
                  instantiateTree(render(custom))
                ]);
    
  }
}

function inflateTree(el) {
  switch (el.tag | 0) {
    case 0 : 
        var contents = el[0];
        return /* MString */Block.__(0, [
                  contents,
                  document.createTextNode(contents)
                ]);
    case 1 : 
        var domProps = el[1];
        var string = el[0];
        var node = createElement(string, domProps);
        var children = Belt_List.map(el[2], inflateTree);
        Belt_List.forEach(children, (function (child) {
                node.appendChild(getDomNode(child));
                return /* () */0;
              }));
        return /* MBuiltin */Block.__(1, [
                  string,
                  domProps,
                  node,
                  children
                ]);
    case 2 : 
        var custom = el[0];
        var mountedTree = inflateTree(el[1]);
        var container = /* record */[
          /* custom */custom,
          /* mountedTree */mountedTree
        ];
        onChange(custom, (function (custom) {
                container[/* custom */0] = custom;
                container[/* mountedTree */1] = reconcileTrees(container[/* mountedTree */1], render(custom));
                return /* () */0;
              }));
        return /* MCustom */Block.__(2, [container]);
    
  }
}

function reconcileTrees(prev, next) {
  var exit = 0;
  switch (prev.tag | 0) {
    case 0 : 
        var node = prev[1];
        switch (next.tag | 0) {
          case 0 : 
              var b = next[0];
              if (prev[0] === b) {
                return prev;
              } else {
                node.textContent = b;
                return /* MString */Block.__(0, [
                          b,
                          node
                        ]);
              }
          case 1 : 
          case 2 : 
              exit = 1;
              break;
          
        }
        break;
    case 1 : 
        var node$1 = prev[2];
        switch (next.tag | 0) {
          case 1 : 
              var b$1 = next[0];
              if (prev[0] === b$1) {
                var bProps = next[1];
                setDomProps(node$1, bProps);
                return /* MBuiltin */Block.__(1, [
                          b$1,
                          bProps,
                          node$1,
                          reconcileChildren(node$1, prev[3], next[2])
                        ]);
              } else {
                exit = 1;
              }
              break;
          case 0 : 
          case 2 : 
              exit = 1;
              break;
          
        }
        break;
    case 2 : 
        var a = prev[0];
        switch (next.tag | 0) {
          case 0 : 
          case 1 : 
              exit = 1;
              break;
          case 2 : 
              var match = Curry._1(next[0][/* clone */1], a[/* custom */0]);
              if (match !== undefined) {
                var custom = match;
                var tree = reconcileTrees(a[/* mountedTree */1], render(custom));
                a[/* custom */0] = custom;
                a[/* mountedTree */1] = tree;
                return /* MCustom */Block.__(2, [a]);
              } else {
                var tree$1 = inflateTree(instantiateTree(next));
                getDomNode(prev).replaceWith(getDomNode(tree$1));
                return tree$1;
              }
          
        }
        break;
    
  }
  if (exit === 1) {
    var tree$2 = inflateTree(instantiateTree(next));
    getDomNode(prev).replaceWith(getDomNode(tree$2));
    return tree$2;
  }
  
}

function reconcileChildren(parentNode, aChildren, bChildren) {
  if (aChildren) {
    if (bChildren) {
      return /* :: */[
              reconcileTrees(aChildren[0], bChildren[0]),
              reconcileChildren(parentNode, aChildren[1], bChildren[1])
            ];
    } else {
      Belt_List.forEach(aChildren, (function (child) {
              parentNode.removeChild(getDomNode(child));
              return /* () */0;
            }));
      return /* [] */0;
    }
  } else if (bChildren) {
    var more = Belt_List.map(bChildren, (function (child) {
            return inflateTree(instantiateTree(child));
          }));
    Belt_List.forEach(more, (function (child) {
            parentNode.appendChild(getDomNode(child));
            return /* () */0;
          }));
    return more;
  } else {
    return /* [] */0;
  }
}

function mount(el, node) {
  var tree = inflateTree(instantiateTree(el));
  node.appendChild(getDomNode(tree));
  return /* () */0;
}

export {
  setDomProps ,
  createElement ,
  updateDomProps ,
  Maker ,
  render ,
  onChange ,
  getDomNode ,
  instantiateTree ,
  inflateTree ,
  reconcileTrees ,
  reconcileChildren ,
  mount ,
  
}
/* No side effect */
