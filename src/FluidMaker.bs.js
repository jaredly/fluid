// Generated by BUCKLESCRIPT VERSION 4.0.7000, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bsb-native/lib/js/block.js");
var Curry = require("bsb-native/lib/js/curry.js");
var Layout = require("./Layout.bs.js");
var Caml_obj = require("bsb-native/lib/js/caml_obj.js");
var Belt_List = require("bsb-native/lib/js/belt_List.js");
var Pervasives = require("bsb-native/lib/js/pervasives.js");
var Js_primitive = require("bsb-native/lib/js/js_primitive.js");

function F(NativeInterface) {
  var makePending = function (inst) {
    switch (inst.tag | 0) {
      case 0 : 
          return /* PBuiltin */Block.__(0, [
                    inst[0],
                    undefined,
                    Belt_List.map(inst[1], makePending),
                    inst[2]
                  ]);
      case 1 : 
          return /* PCustom */Block.__(1, [
                    /* record */[
                      /* custom */inst[0],
                      /* mountedTree : Pending */Block.__(0, [makePending(inst[1])])
                    ],
                    inst[2]
                  ]);
      case 2 : 
          return /* PNull */Block.__(2, [
                    undefined,
                    inst[0]
                  ]);
      
    }
  };
  var makeComponent = function (identity, render) {
    return /* record */[
            /* init */(function (param) {
                return /* WithState */[/* record */[
                          /* identity */identity,
                          /* render */render,
                          /* hooks : record */[/* contents */undefined],
                          /* invalidated */false,
                          /* reconciler */undefined,
                          /* onChange */(function (param) {
                              return /* () */0;
                            })
                        ]];
              }),
            /* clone */(function (param) {
                var contents = param[0];
                if (contents[/* identity */0] === identity) {
                  if (contents[/* render */1] === render) {
                    return /* Same */925282182;
                  } else {
                    return /* `Compatible */[
                            785637236,
                            /* WithState */[/* record */[
                                /* identity */contents[/* identity */0],
                                /* render */render,
                                /* hooks */contents[/* hooks */2],
                                /* invalidated */contents[/* invalidated */3],
                                /* reconciler */contents[/* reconciler */4],
                                /* onChange */contents[/* onChange */5]
                              ]]
                          ];
                  }
                } else {
                  return /* Different */-890978471;
                }
              })
          ];
  };
  var Maker = /* module */[/* makeComponent */makeComponent];
  var runRender = function (param) {
    var component = param[0];
    var effects = /* record */[/* contents : [] */0];
    var hooks_000 = function (param) {
      component[/* invalidated */3] = true;
      return Curry._1(component[/* onChange */5], /* () */0);
    };
    var hooks_001 = function (oldData, data, reconcile) {
      component[/* reconciler */4] = /* tuple */[
        oldData,
        data,
        reconcile
      ];
      return /* () */0;
    };
    var hooks_002 = function (cleanup, fn, setCleanup) {
      effects[/* contents */0] = /* :: */[
        /* record */[
          /* cleanup */cleanup,
          /* fn */fn,
          /* setCleanup */setCleanup
        ],
        effects[/* contents */0]
      ];
      return /* () */0;
    };
    var hooks_003 = /* current */component[/* hooks */2];
    var hooks = /* record */[
      hooks_000,
      hooks_001,
      hooks_002,
      hooks_003
    ];
    component[/* invalidated */3] = false;
    var tree = Curry._1(component[/* render */1], hooks);
    return /* tuple */[
            tree,
            effects[0]
          ];
  };
  var getNativeNode = function (_tree) {
    while(true) {
      var tree = _tree;
      switch (tree.tag | 0) {
        case 0 : 
            return Js_primitive.some(tree[1]);
        case 1 : 
            var match = tree[0][/* mountedTree */1];
            if (match.tag) {
              _tree = match[0];
              continue ;
            } else {
              return getNativePending(match[0]);
            }
        case 2 : 
            return Js_primitive.some(tree[0]);
        
      }
    };
  };
  var getNativePending = function (_tree) {
    while(true) {
      var tree = _tree;
      switch (tree.tag | 0) {
        case 0 : 
            var match = tree[1];
            if (match !== undefined) {
              return Js_primitive.some(match[1]);
            } else {
              return undefined;
            }
        case 1 : 
            var match$1 = tree[0][/* mountedTree */1];
            if (match$1.tag) {
              return getNativeNode(match$1[0]);
            } else {
              _tree = match$1[0];
              continue ;
            }
        case 2 : 
            return tree[0];
        
      }
    };
  };
  var getInstanceLayout = function (_element) {
    while(true) {
      var element = _element;
      switch (element.tag | 0) {
        case 0 : 
            return element[2];
        case 1 : 
            _element = element[1];
            continue ;
        case 2 : 
            return element[0];
        
      }
    };
  };
  var getMountedLayout = function (_element) {
    while(true) {
      var element = _element;
      switch (element.tag | 0) {
        case 0 : 
            return element[3];
        case 1 : 
            var match = element[0][/* mountedTree */1];
            if (match.tag) {
              _element = match[0];
              continue ;
            } else {
              return getPendingLayout(match[0]);
            }
        case 2 : 
            return element[1];
        
      }
    };
  };
  var getPendingLayout = function (_element) {
    while(true) {
      var element = _element;
      switch (element.tag | 0) {
        case 0 : 
            return element[3];
        case 1 : 
            var match = element[0][/* mountedTree */1];
            if (match.tag) {
              return getMountedLayout(match[0]);
            } else {
              _element = match[0];
              continue ;
            }
        case 2 : 
            return element[1];
        
      }
    };
  };
  var instantiateTree = function (el) {
    if (typeof el === "number") {
      return /* INull */Block.__(2, [Layout.createNode(/* array */[], Layout.style(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, /* () */0))]);
    } else if (el.tag) {
      var custom = Curry._1(el[0][/* init */0], /* () */0);
      var match = runRender(custom);
      return /* ICustom */Block.__(1, [
                custom,
                instantiateTree(match[0]),
                match[1]
              ]);
    } else {
      var measure = el[3];
      var layout = el[2];
      var ichildren = Belt_List.map(el[1], instantiateTree);
      var childLayouts = Belt_List.toArray(Belt_List.map(ichildren, getInstanceLayout));
      var style = layout !== undefined ? layout : Layout.style(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, /* () */0);
      return /* IBuiltin */Block.__(0, [
                el[0],
                ichildren,
                measure !== undefined ? Layout.createNodeWithMeasure(childLayouts, style, measure) : Layout.createNode(childLayouts, style)
              ]);
    }
  };
  var runEffect = function (param) {
    var cleanup = param[/* cleanup */0];
    if (cleanup !== undefined) {
      Curry._1(cleanup, /* () */0);
    }
    return Curry._1(param[/* setCleanup */2], Curry._1(param[/* fn */1], /* () */0));
  };
  var mountPending = function (enqueue, el) {
    switch (el.tag | 0) {
      case 0 : 
          var match = el[1];
          var $$native = el[0];
          if (match !== undefined) {
            var match$1 = match;
            var node = match$1[1];
            Curry._3(NativeInterface[/* update */2], $$native, node, match$1[0]);
            return /* MBuiltin */Block.__(0, [
                      $$native,
                      node,
                      Belt_List.map(el[2], (function (param) {
                              return mountPending(enqueue, param);
                            })),
                      el[3]
                    ]);
          } else {
            var layout = el[3];
            var node$1 = Curry._2(NativeInterface[/* inflate */3], $$native, layout);
            var children = Belt_List.map(el[2], (function (param) {
                    return mountPending(enqueue, param);
                  }));
            Belt_List.forEach(Belt_List.map(children, getNativeNode), (function (childNode) {
                    if (childNode !== undefined) {
                      return Curry._2(NativeInterface[/* appendChild */6], node$1, Js_primitive.valFromOption(childNode));
                    } else {
                      return Pervasives.failwith("Inflating a tree that's still pending");
                    }
                  }));
            return /* MBuiltin */Block.__(0, [
                      $$native,
                      node$1,
                      children,
                      layout
                    ]);
          }
      case 1 : 
          var container = el[0];
          var custom = container[/* custom */0];
          var match$2 = container[/* mountedTree */1];
          if (match$2.tag) {
            if (el[1] !== /* [] */0) {
              console.log("Warning: Unchagned node had effects");
            }
            return /* MCustom */Block.__(1, [container]);
          } else {
            var match$3 = container[/* mountedTree */1];
            var mountedTree = mountPending(enqueue, match$3[0]);
            var container$1 = /* record */[
              /* custom */custom,
              /* mountedTree : Mounted */Block.__(1, [mountedTree])
            ];
            custom[0][/* onChange */5] = (function (param) {
                return Curry._1(enqueue, container$1);
              });
            Belt_List.forEach(el[1], runEffect);
            return /* MCustom */Block.__(1, [container$1]);
          }
      case 2 : 
          var match$4 = el[0];
          if (match$4 !== undefined) {
            return /* MNull */Block.__(2, [
                      Js_primitive.valFromOption(match$4),
                      el[1]
                    ]);
          } else {
            return /* MNull */Block.__(2, [
                      Curry._1(NativeInterface[/* createNullNode */5], /* () */0),
                      el[1]
                    ]);
          }
      
    }
  };
  var reconcileTrees = function (enqueue, prev, next) {
    switch (prev.tag | 0) {
      case 0 : 
          var aLayout = prev[3];
          var node = prev[1];
          var aElement = prev[0];
          if (typeof next === "number" || next.tag) {
            return makePending(instantiateTree(next));
          } else {
            var bLayoutStyle = next[2];
            var bElement = next[0];
            if (Curry._3(NativeInterface[/* canUpdate */1], aElement, node, bElement)) {
              aLayout[/* style */1] = bLayoutStyle !== undefined ? bLayoutStyle : Layout.style(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, /* () */0);
              return /* PBuiltin */Block.__(0, [
                        bElement,
                        /* tuple */[
                          aElement,
                          node
                        ],
                        reconcileChildren(enqueue, node, prev[2], next[1]),
                        aLayout
                      ]);
            } else {
              return makePending(instantiateTree(next));
            }
          }
      case 1 : 
          var a = prev[0];
          if (typeof next === "number" || !next.tag) {
            return makePending(instantiateTree(next));
          } else {
            var match = Curry._1(next[0][/* clone */1], a[/* custom */0]);
            if (typeof match === "number") {
              if (match >= 925282182) {
                return /* PCustom */Block.__(1, [
                          a,
                          /* [] */0
                        ]);
              } else {
                return makePending(instantiateTree(next));
              }
            } else {
              var custom = match[1];
              var match$1 = runRender(custom);
              var match$2 = a[/* mountedTree */1];
              if (match$2.tag) {
                var tree = reconcileTrees(enqueue, match$2[0], match$1[0]);
                return /* PCustom */Block.__(1, [
                          /* record */[
                            /* custom */custom,
                            /* mountedTree : Pending */Block.__(0, [tree])
                          ],
                          match$1[1]
                        ]);
              } else {
                return Pervasives.failwith("Reconciling a componenet that's still pending.");
              }
            }
          }
      case 2 : 
          return makePending(instantiateTree(next));
      
    }
  };
  var reconcileChildren = function (enqueue, parentNode, aChildren, bChildren) {
    if (aChildren) {
      if (bChildren) {
        return /* :: */[
                reconcileTrees(enqueue, aChildren[0], bChildren[0]),
                reconcileChildren(enqueue, parentNode, aChildren[1], bChildren[1])
              ];
      } else {
        Belt_List.forEach(Belt_List.keepMap(aChildren, getNativeNode), Curry._1(NativeInterface[/* removeChild */7], parentNode));
        return /* [] */0;
      }
    } else if (bChildren) {
      return Belt_List.map(bChildren, (function (child) {
                    return makePending(instantiateTree(child));
                  }));
    } else {
      return /* [] */0;
    }
  };
  var enqueue = function (root, custom) {
    root[/* invalidatedElements */2] = /* :: */[
      custom,
      root[/* invalidatedElements */2]
    ];
    if (root[/* waiting */3]) {
      return 0;
    } else {
      root[/* waiting */3] = true;
      return Curry._1(NativeInterface[/* setImmediate */0], (function (param) {
                    root[/* waiting */3] = false;
                    var elements = root[/* invalidatedElements */2];
                    root[/* invalidatedElements */2] = /* [] */0;
                    var toUpdate = Belt_List.keepMap(elements, (function (container) {
                            var component = container[/* custom */0];
                            var contents = component[0];
                            if (contents[/* invalidated */3]) {
                              var match = runRender(component);
                              var newElement = match[0];
                              var match$1 = container[/* mountedTree */1];
                              if (match$1.tag) {
                                var mountedTree = match$1[0];
                                var match$2 = contents[/* reconciler */4];
                                var tmp;
                                if (match$2 !== undefined) {
                                  var match$3 = match$2;
                                  tmp = Curry._4(match$3[2], match$3[0], match$3[1], mountedTree, newElement);
                                } else {
                                  tmp = reconcileTrees((function (param) {
                                          return enqueue(root, param);
                                        }), mountedTree, newElement);
                                }
                                return /* tuple */[
                                        container,
                                        tmp,
                                        match[1]
                                      ];
                              } else {
                                console.log("Updating a pending tree...");
                                return undefined;
                              }
                            }
                            
                          }));
                    Layout.layout(root[/* layout */0]);
                    debugger;
                    return Belt_List.forEach(toUpdate, (function (param) {
                                  Belt_List.forEach(param[2], runEffect);
                                  param[0][/* mountedTree */1] = /* Mounted */Block.__(1, [mountPending((function (param) {
                                              return enqueue(root, param);
                                            }), param[1])]);
                                  return /* () */0;
                                }));
                  }));
    }
  };
  var mount = function (el, node) {
    var instances = instantiateTree(el);
    var instanceLayout = getInstanceLayout(instances);
    Layout.layout(instanceLayout);
    var root = /* record */[
      /* layout */instanceLayout,
      /* node */undefined,
      /* invalidatedElements : [] */0,
      /* waiting */false
    ];
    var tree = mountPending((function (param) {
            return enqueue(root, param);
          }), makePending(instances));
    var match = getNativeNode(tree);
    if (match !== undefined) {
      var childNode = Js_primitive.valFromOption(match);
      root[/* node */1] = Js_primitive.some(childNode);
      return Curry._2(NativeInterface[/* appendChild */6], node, childNode);
    } else {
      return Pervasives.failwith("Still pending?");
    }
  };
  var useReconciler = function (data, fn, hooks) {
    var match = hooks[/* current */3][0];
    var next;
    if (match !== undefined) {
      var match$1 = match;
      Curry._3(hooks[/* setReconciler */1], match$1[0], data, fn);
      next = match$1[1];
    } else {
      next = /* record */[/* contents */undefined];
    }
    hooks[/* current */3][0] = /* tuple */[
      data,
      next
    ];
    return /* tuple */[
            /* () */0,
            hooks
          ];
  };
  var useRef = function (initial, hooks) {
    var match = hooks[/* current */3][0];
    if (match !== undefined) {
      var match$1 = match;
      return /* tuple */[
              match$1[0],
              /* record */[
                /* invalidate */hooks[/* invalidate */0],
                /* setReconciler */hooks[/* setReconciler */1],
                /* triggerEffect */hooks[/* triggerEffect */2],
                /* current */match$1[1]
              ]
            ];
    } else {
      var r = /* record */[/* contents */initial];
      var next = /* record */[/* contents */undefined];
      hooks[/* current */3][0] = /* tuple */[
        r,
        next
      ];
      return /* tuple */[
              r,
              /* record */[
                /* invalidate */hooks[/* invalidate */0],
                /* setReconciler */hooks[/* setReconciler */1],
                /* triggerEffect */hooks[/* triggerEffect */2],
                /* current */next
              ]
            ];
    }
  };
  var useState = function (initial, hooks) {
    var match = hooks[/* current */3][0];
    var match$1;
    if (match !== undefined) {
      var match$2 = match;
      match$1 = /* tuple */[
        match$2[0],
        match$2[1]
      ];
    } else {
      var next = /* record */[/* contents */undefined];
      hooks[/* current */3][0] = /* tuple */[
        initial,
        next
      ];
      match$1 = /* tuple */[
        initial,
        next
      ];
    }
    var next$1 = match$1[1];
    return /* tuple */[
            /* tuple */[
              match$1[0],
              (function (v) {
                  hooks[/* current */3][0] = /* tuple */[
                    v,
                    next$1
                  ];
                  return Curry._1(hooks[/* invalidate */0], /* () */0);
                })
            ],
            /* record */[
              /* invalidate */hooks[/* invalidate */0],
              /* setReconciler */hooks[/* setReconciler */1],
              /* triggerEffect */hooks[/* triggerEffect */2],
              /* current */next$1
            ]
          ];
  };
  var useReducer = function (initial, reducer, hooks) {
    var match = useState(initial, hooks);
    var match$1 = match[0];
    var setState = match$1[1];
    var state = match$1[0];
    return /* tuple */[
            /* tuple */[
              state,
              (function (action) {
                  return Curry._1(setState, Curry._2(reducer, state, action));
                })
            ],
            match[1]
          ];
  };
  var newEffect = function (fn, args) {
    return /* record */[
            /* args */args,
            /* cleanup : record */[/* contents */undefined],
            /* fn */fn
          ];
  };
  var useEffect = function (fn, args, hooks) {
    var match = hooks[/* current */3][0];
    var match$1;
    if (match !== undefined) {
      var match$2 = match;
      var effect = match$2[0];
      var effect$1 = Caml_obj.caml_notequal(effect[/* args */0], args) ? (Curry._3(hooks[/* triggerEffect */2], effect[/* cleanup */1][/* contents */0], fn, (function (v) {
                  effect[/* cleanup */1][/* contents */0] = v;
                  return /* () */0;
                })), /* record */[
            /* args */args,
            /* cleanup */effect[/* cleanup */1],
            /* fn */fn
          ]) : effect;
      match$1 = /* tuple */[
        effect$1,
        match$2[1]
      ];
    } else {
      var effect$2 = newEffect(fn, args);
      Curry._3(hooks[/* triggerEffect */2], effect$2[/* cleanup */1][/* contents */0], fn, (function (v) {
              effect$2[/* cleanup */1][/* contents */0] = v;
              return /* () */0;
            }));
      match$1 = /* tuple */[
        effect$2,
        /* record */[/* contents */undefined]
      ];
    }
    var next = match$1[1];
    hooks[/* current */3][0] = /* tuple */[
      match$1[0],
      next
    ];
    return /* tuple */[
            /* () */0,
            /* record */[
              /* invalidate */hooks[/* invalidate */0],
              /* setReconciler */hooks[/* setReconciler */1],
              /* triggerEffect */hooks[/* triggerEffect */2],
              /* current */next
            ]
          ];
  };
  var useMemo = function (fn, args, hooks) {
    var match = hooks[/* current */3][0];
    var match$1;
    if (match !== undefined) {
      var match$2 = match;
      var match$3 = match$2[0];
      var match$4 = Caml_obj.caml_equal(match$3[1], args);
      var value = match$4 ? match$3[0] : Curry._1(fn, /* () */0);
      match$1 = /* tuple */[
        value,
        match$2[1]
      ];
    } else {
      match$1 = /* tuple */[
        Curry._1(fn, /* () */0),
        /* record */[/* contents */undefined]
      ];
    }
    var next = match$1[1];
    var value$1 = match$1[0];
    hooks[/* current */3][0] = /* tuple */[
      /* tuple */[
        value$1,
        args
      ],
      next
    ];
    return /* tuple */[
            value$1,
            /* record */[
              /* invalidate */hooks[/* invalidate */0],
              /* setReconciler */hooks[/* setReconciler */1],
              /* triggerEffect */hooks[/* triggerEffect */2],
              /* current */next
            ]
          ];
  };
  var useCallback = function (fn, args, hooks) {
    return useMemo((function (param) {
                  return fn;
                }), args, hooks);
  };
  var Hooks = /* module */[
    /* useReconciler */useReconciler,
    /* useRef */useRef,
    /* useState */useState,
    /* useReducer */useReducer,
    /* newEffect */newEffect,
    /* useEffect */useEffect,
    /* useMemo */useMemo,
    /* useCallback */useCallback
  ];
  return /* module */[
          /* makePending */makePending,
          /* Maker */Maker,
          /* runRender */runRender,
          /* getNativeNode */getNativeNode,
          /* getNativePending */getNativePending,
          /* getInstanceLayout */getInstanceLayout,
          /* getMountedLayout */getMountedLayout,
          /* getPendingLayout */getPendingLayout,
          /* instantiateTree */instantiateTree,
          /* runEffect */runEffect,
          /* mountPending */mountPending,
          /* reconcileTrees */reconcileTrees,
          /* reconcileChildren */reconcileChildren,
          /* enqueue */enqueue,
          /* mount */mount,
          /* Hooks */Hooks
        ];
}

exports.F = F;
/* Layout Not a pure module */
